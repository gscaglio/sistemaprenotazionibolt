-- Create transaction_logs table for tracking operations
CREATE TABLE IF NOT EXISTS transaction_logs (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    transaction_id UUID NOT NULL,
    operation TEXT NOT NULL,
    status TEXT NOT NULL,
    metadata JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc', now())
);

-- Create index on transaction_logs
CREATE INDEX IF NOT EXISTS idx_transaction_logs_transaction_id ON transaction_logs(transaction_id);
CREATE INDEX IF NOT EXISTS idx_transaction_logs_created_at ON transaction_logs(created_at);

-- Enable RLS on transaction_logs
ALTER TABLE transaction_logs ENABLE ROW LEVEL SECURITY;

-- Create RPC function for emergency mode activation
CREATE OR REPLACE FUNCTION activate_emergency_mode(p_user_id UUID)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    transaction_id UUID;
    saved_state jsonb;
BEGIN
    -- Generate transaction ID
    transaction_id := gen_random_uuid();
    
    -- Start transaction
    BEGIN
        -- Save current availability state
        SELECT jsonb_agg(to_jsonb(a)) INTO saved_state
        FROM availability a
        WHERE a.date >= CURRENT_DATE;
        
        -- Update all future availability to blocked
        UPDATE availability
        SET 
            available = false,
            blocked_reason = 'emergency',
            price_override = NULL,
            updated_at = now()
        WHERE date >= CURRENT_DATE;
        
        -- Log transaction
        INSERT INTO transaction_logs (transaction_id, operation, status, metadata)
        VALUES (
            transaction_id,
            'activate_emergency_mode',
            'completed',
            jsonb_build_object(
                'user_id', p_user_id,
                'affected_records', (SELECT count(*) FROM availability WHERE date >= CURRENT_DATE)
            )
        );
        
        RETURN jsonb_build_object(
            'saved_availability', saved_state,
            'transaction_id', transaction_id
        );
    EXCEPTION WHEN OTHERS THEN
        -- Log failed transaction
        INSERT INTO transaction_logs (transaction_id, operation, status, metadata)
        VALUES (
            transaction_id,
            'activate_emergency_mode',
            'failed',
            jsonb_build_object(
                'user_id', p_user_id,
                'error', SQLERRM
            )
        );
        RAISE;
    END;
END;
$$;

-- Create RPC function for emergency mode deactivation
CREATE OR REPLACE FUNCTION deactivate_emergency_mode(p_user_id UUID, p_saved_availability jsonb)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    transaction_id UUID;
    availability_record jsonb;
BEGIN
    -- Generate transaction ID
    transaction_id := gen_random_uuid();
    
    -- Start transaction
    BEGIN
        -- Restore saved availability state
        FOR availability_record IN SELECT * FROM jsonb_array_elements(p_saved_availability)
        LOOP
            INSERT INTO availability (
                room_id,
                date,
                available,
                price_override,
                blocked_reason,
                notes,
                updated_at
            )
            VALUES (
                (availability_record->>'room_id')::integer,
                (availability_record->>'date')::date,
                (availability_record->>'available')::boolean,
                (availability_record->>'price_override')::numeric,
                availability_record->>'blocked_reason',
                availability_record->>'notes',
                now()
            )
            ON CONFLICT (room_id, date) DO UPDATE
            SET
                available = EXCLUDED.available,
                price_override = EXCLUDED.price_override,
                blocked_reason = EXCLUDED.blocked_reason,
                notes = EXCLUDED.notes,
                updated_at = EXCLUDED.updated_at;
        END LOOP;
        
        -- Log successful transaction
        INSERT INTO transaction_logs (transaction_id, operation, status, metadata)
        VALUES (
            transaction_id,
            'deactivate_emergency_mode',
            'completed',
            jsonb_build_object(
                'user_id', p_user_id,
                'restored_records', jsonb_array_length(p_saved_availability)
            )
        );
    EXCEPTION WHEN OTHERS THEN
        -- Log failed transaction
        INSERT INTO transaction_logs (transaction_id, operation, status, metadata)
        VALUES (
            transaction_id,
            'deactivate_emergency_mode',
            'failed',
            jsonb_build_object(
                'user_id', p_user_id,
                'error', SQLERRM
            )
        );
        RAISE;
    END;
END;
$$;

-- Create policies for transaction_logs
CREATE POLICY "Allow authenticated users to view transaction logs"
    ON transaction_logs FOR SELECT TO authenticated 
    USING (true);

-- Create cleanup function for transaction logs
CREATE OR REPLACE FUNCTION cleanup_old_transaction_logs()
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    DELETE FROM transaction_logs
    WHERE created_at < NOW() - INTERVAL '30 days';
END;
$$;

-- Schedule cleanup job if pg_cron is available
DO $$
BEGIN
    IF EXISTS (
        SELECT 1 
        FROM pg_extension 
        WHERE extname = 'pg_cron'
    ) THEN
        PERFORM cron.schedule(
            'cleanup-transaction-logs',
            '0 0 * * 0',  -- Every Sunday at midnight
            'SELECT cleanup_old_transaction_logs()'
        );
    END IF;
END $$;