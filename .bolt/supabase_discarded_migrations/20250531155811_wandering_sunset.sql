-- Drop existing policies if they exist
DO $$ 
BEGIN
    EXECUTE (
        SELECT string_agg('DROP POLICY IF EXISTS "' || polname || '" ON error_logs;', E'\n')
        FROM pg_policies 
        WHERE tablename = 'error_logs'
    );
EXCEPTION 
    WHEN undefined_table THEN NULL;
END $$;

-- Create error_logs table if it doesn't exist
CREATE TABLE IF NOT EXISTS error_logs (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    level VARCHAR(20) NOT NULL CHECK (level IN ('debug', 'info', 'warning', 'error', 'critical')),
    message TEXT NOT NULL,
    error_stack TEXT,
    context JSONB,
    browser_info JSONB,
    user_id UUID REFERENCES auth.users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc', now()),
    resolved_at TIMESTAMP WITH TIME ZONE,
    resolution_notes TEXT
);

-- Add indexes if they don't exist
DO $$ 
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'error_logs_level_idx') THEN
        CREATE INDEX error_logs_level_idx ON error_logs(level);
    END IF;
    
    IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'error_logs_created_at_idx') THEN
        CREATE INDEX error_logs_created_at_idx ON error_logs(created_at);
    END IF;
    
    IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'error_logs_user_id_idx') THEN
        CREATE INDEX error_logs_user_id_idx ON error_logs(user_id);
    END IF;
END $$;

-- Enable RLS
ALTER TABLE error_logs ENABLE ROW LEVEL SECURITY;

-- Recreate policies
CREATE POLICY "Allow authenticated users to view error logs"
    ON error_logs FOR SELECT TO authenticated 
    USING (true);

CREATE POLICY "Allow authenticated users to insert error logs"
    ON error_logs FOR INSERT TO authenticated 
    WITH CHECK (true);

CREATE POLICY "Allow authenticated users to update error logs"
    ON error_logs FOR UPDATE TO authenticated 
    USING (true) WITH CHECK (true);

-- Create or replace cleanup function
CREATE OR REPLACE FUNCTION clean_old_error_logs()
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
    DELETE FROM error_logs
    WHERE created_at < NOW() - INTERVAL '90 days'
    AND level NOT IN ('error', 'critical');
    
    DELETE FROM error_logs
    WHERE created_at < NOW() - INTERVAL '365 days';
END;
$$;

-- Schedule cleanup job if pg_cron is available
DO $$
BEGIN
    IF EXISTS (
        SELECT 1 
        FROM pg_extension 
        WHERE extname = 'pg_cron'
    ) THEN
        PERFORM cron.schedule(
            'clean-old-error-logs',
            '0 0 * * 0', -- Every Sunday at midnight
            'SELECT clean_old_error_logs()'
        );
    END IF;
EXCEPTION 
    WHEN undefined_function THEN 
        RAISE NOTICE 'pg_cron extension not available, skipping job scheduling';
END $$;